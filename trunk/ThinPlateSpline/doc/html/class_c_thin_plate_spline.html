<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Thin-Plate-Spline Interpolation Class: CThinPlateSpline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CThinPlateSpline Class Reference</h1><!-- doxytag: class="CThinPlateSpline" -->
<p><a class="el" href="class_c_thin_plate_spline.html" title="CThinPlateSpline.">CThinPlateSpline</a>.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_thin_plate_spline_8h_source.html">CThinPlateSpline.h</a>&gt;</code></p>

<p><a href="class_c_thin_plate_spline-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#a768d5f195fefea81bf4762c90bb4ac55">CThinPlateSpline</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#a19109ccbfa916bf7eb9349e591e3df21">CThinPlateSpline</a> (const std::vector&lt; Point &gt; &amp;pS, const std::vector&lt; Point &gt; &amp;pD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#af34dcd3e091e273051f5a8b2a53c0483">~CThinPlateSpline</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Point&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#ad1b5341595cece889a3f6a3f4f2dbc24">interpolate</a> (const Point &amp;p, const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a> tpsInter=BACK_WARP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#a14ae96e9b01dd7adc7fd0ee57b83116a">addCorrespondence</a> (const Point &amp;pS, const Point &amp;pD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#a80438eb21a104d855d6ca183b98515ac">warpImage</a> (const Mat &amp;src, Mat &amp;dst, float lambda=0.001, const int interpolation=INTER_CUBIC, const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a> tpsInter=BACK_WARP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#ac3851eb4fcb087783c2e57e3e703e6a3">setCorrespondences</a> (const std::vector&lt; Point &gt; &amp;pS, const std::vector&lt; Point &gt; &amp;pD)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#a99e7e8bb4118f9ffd2e1e52bb8c3cc72">getMaps</a> (Mat &amp;mapx, Mat &amp;mapy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_thin_plate_spline.html#ab4fde8b32ab201e0dfd53a27a79462da">computeMaps</a> (const Size &amp;dstSize, Mat_&lt; float &gt; &amp;mapx, Mat_&lt; float &gt; &amp;mapy, const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a> tpsInter=BACK_WARP)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="class_c_thin_plate_spline.html" title="CThinPlateSpline.">CThinPlateSpline</a>. </p>
<p>This is the implementation of the original thin plate splien algorithm introduce by Bookstein in 1989. This class helps you to use the algorithm easy and efficient. See the function comments for more information. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a768d5f195fefea81bf4762c90bb4ac55"></a><!-- doxytag: member="CThinPlateSpline::CThinPlateSpline" ref="a768d5f195fefea81bf4762c90bb4ac55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CThinPlateSpline::CThinPlateSpline </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_c_thin_plate_spline.html" title="CThinPlateSpline.">CThinPlateSpline</a> standard constructor.</p>
<p>The standard constructor will do nothing else than set all control flags to the initial state. These contral flags are only used internally. </p>

</div>
</div>
<a class="anchor" id="a19109ccbfa916bf7eb9349e591e3df21"></a><!-- doxytag: member="CThinPlateSpline::CThinPlateSpline" ref="a19109ccbfa916bf7eb9349e591e3df21" args="(const std::vector&lt; Point &gt; &amp;pS, const std::vector&lt; Point &gt; &amp;pD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CThinPlateSpline::CThinPlateSpline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pD</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_c_thin_plate_spline.html" title="CThinPlateSpline.">CThinPlateSpline</a> constructor.</p>
<p>One has the possibility to create an object and initializing it directly with corresponding point sets that will allow a direct use of the class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pS</em>&nbsp;</td><td>Reference to a STL vector that holds the points of the source image.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Reference to a STL vector that holds the points of the target image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af34dcd3e091e273051f5a8b2a53c0483"></a><!-- doxytag: member="CThinPlateSpline::~CThinPlateSpline" ref="af34dcd3e091e273051f5a8b2a53c0483" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CThinPlateSpline::~CThinPlateSpline </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="class_c_thin_plate_spline.html" title="CThinPlateSpline.">CThinPlateSpline</a> standard destructor.</p>
<p>The standard destructor does nothing. All used datastructures are self- maintaining. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a14ae96e9b01dd7adc7fd0ee57b83116a"></a><!-- doxytag: member="CThinPlateSpline::addCorrespondence" ref="a14ae96e9b01dd7adc7fd0ee57b83116a" args="(const Point &amp;pS, const Point &amp;pD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CThinPlateSpline::addCorrespondence </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>pS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>pD</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to add new corresponding points to the internal representation. When this function is called all internal states are reset so that the spline coefficients are recomputed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pS</em>&nbsp;</td><td>Reference to a point from the source image</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Reference to a point from the target image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ab4fde8b32ab201e0dfd53a27a79462da"></a><!-- doxytag: member="CThinPlateSpline::computeMaps" ref="ab4fde8b32ab201e0dfd53a27a79462da" args="(const Size &amp;dstSize, Mat_&lt; float &gt; &amp;mapx, Mat_&lt; float &gt; &amp;mapy, const TPS_INTERPOLATION tpsInter=BACK_WARP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CThinPlateSpline::computeMaps </td>
          <td>(</td>
          <td class="paramtype">const Size &amp;&nbsp;</td>
          <td class="paramname"> <em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat_&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mapx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat_&lt; float &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>mapy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a>&nbsp;</td>
          <td class="paramname"> <em>tpsInter</em> = <code>BACK_WARP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If you want to get your hands on the maps to interpolate for yourself they have to be computed first. The following function will do this. The reason why <a class="el" href="class_c_thin_plate_spline.html#a99e7e8bb4118f9ffd2e1e52bb8c3cc72">getMaps()</a> doesen't do this for itself is, that the getMaps function is supposed to only return the arrays without knowing if you want FORWARD- or BACK_WARP maps.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dstSize</em>&nbsp;</td><td>size of the destination image. Here you can insert any size you like. The algorithm will simply evaluate the spline and look on the correct position in the array. If there is no value, the result will be black.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapx</em>&nbsp;</td><td>sub-pixel x-coordinates</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapy</em>&nbsp;</td><td>sub-pixel y-coordinates</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpsInter</em>&nbsp;</td><td>This parameter defines the direction of the interpolation function. Possible values are: <br/>
 FORWARD_WARP, <br/>
 BACK_WARP</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a99e7e8bb4118f9ffd2e1e52bb8c3cc72"></a><!-- doxytag: member="CThinPlateSpline::getMaps" ref="a99e7e8bb4118f9ffd2e1e52bb8c3cc72" args="(Mat &amp;mapx, Mat &amp;mapy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CThinPlateSpline::getMaps </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&nbsp;</td>
          <td class="paramname"> <em>mapx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&nbsp;</td>
          <td class="paramname"> <em>mapy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The getMaps function is used to get your hands on the x- and y-values that are used for the interpolation. The maps contain the sub-pixel values which are used by cv::remap to interpolate each pixel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mapx</em>&nbsp;</td><td>sub-pixel x-coordinates</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapy</em>&nbsp;</td><td>sub-pixel y-coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ad1b5341595cece889a3f6a3f4f2dbc24"></a><!-- doxytag: member="CThinPlateSpline::interpolate" ref="ad1b5341595cece889a3f6a3f4f2dbc24" args="(const Point &amp;p, const TPS_INTERPOLATION tpsInter=BACK_WARP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point CThinPlateSpline::interpolate </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a>&nbsp;</td>
          <td class="paramname"> <em>tpsInter</em> = <code>BACK_WARP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interpolation function is used to derive the position of a point transformed by the pre-computed spline coefficients. One has the possibility to warp forward or backward. The interpolation function determines for itself if the maps are suitable for forward/backward warps and recomputes them if necessary</p>
<p>The spline is evaluated by computing the minimization of the energy function defined in Bookstein's original paper. The minimization function for the two dimensional problem is /f$ f(x,y) = a_1 + a_x*x + a_y * y + {i=1}^n w_i U(|P_i-(x,y)|)/f$</p>
<p>As one can easily see the computation of one transformed pixel takes /f$O(n^2)/f$ operations where n is the number of corresponding points.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Reference to the point that is going to be transformed/interpolated</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpsInter</em>&nbsp;</td><td>defines if the point p is interpolated forward or backward</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function returns the interpolation result as cv::Point-structure </dd></dl>

</div>
</div>
<a class="anchor" id="ac3851eb4fcb087783c2e57e3e703e6a3"></a><!-- doxytag: member="CThinPlateSpline::setCorrespondences" ref="ac3851eb4fcb087783c2e57e3e703e6a3" args="(const std::vector&lt; Point &gt; &amp;pS, const std::vector&lt; Point &gt; &amp;pD)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CThinPlateSpline::setCorrespondences </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pD</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to set the corresponding points directily. Instead of adding single point correspondences one can put hole vectors of points into this class, which are used to compute the spline coefficients.</p>
<p>Make sure that both vectors have the same size. If this is not the case the computation will fail!</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pS</em>&nbsp;</td><td>Reference to a vector containing the points from the source image</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pD</em>&nbsp;</td><td>Reference to a vector containing the points from the source image</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a80438eb21a104d855d6ca183b98515ac"></a><!-- doxytag: member="CThinPlateSpline::warpImage" ref="a80438eb21a104d855d6ca183b98515ac" args="(const Mat &amp;src, Mat &amp;dst, float lambda=0.001, const int interpolation=INTER_CUBIC, const TPS_INTERPOLATION tpsInter=BACK_WARP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CThinPlateSpline::warpImage </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>lambda</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>interpolation</em> = <code>INTER_CUBIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_c_thin_plate_spline_8h.html#a368eee305bdcd079956898ef290a2b6a">TPS_INTERPOLATION</a>&nbsp;</td>
          <td class="paramname"> <em>tpsInter</em> = <code>BACK_WARP</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a combination of all function of this class. The function is used to directly transform an image according to the corresponding points provided earlier. If not already done, the function will compute the spline coefficients and then compute the transformation maps which will be used to transform the source image into it's destination using the cv::remap function. It is possible to choose the interpolation type as well as the transformation direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Reference to the source image. Nothing will be done with this array other than reading values.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Reference the transformation destination. If dst was allocated before, it will be released and initialized with the correct size, depth etc.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interpolation</em>&nbsp;</td><td>Reference the transformation destination. If dst was allocated before, it will be released and initialized with the correct size, depth etc. All known interpolation function from the OpenCV library are possible: <br/>
 INTER_NEAREST, <br/>
 INTER_LINEAR, <br/>
 INTER_AREA, <br/>
 INTER_CUBIC, <br/>
 INTER_LANCZOS4</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpsInter</em>&nbsp;</td><td>This parameter defines the direction of the interpolation function. Possible values are: <br/>
 FORWARD_WARP, <br/>
 BACK_WARP</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Matthias Schmieder/Development/projects/ThinPlateSpline/ThinPlateSpline/<a class="el" href="_c_thin_plate_spline_8h_source.html">CThinPlateSpline.h</a></li>
<li>C:/Users/Matthias Schmieder/Development/projects/ThinPlateSpline/ThinPlateSpline/CThinPlateSpline.cpp</li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
